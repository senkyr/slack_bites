<!DOCTYPE html>
<html lang="cs" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Snake (monochrome, responsive)</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f0f10;
      --fg: #f3f3f3;
      --mid: #9a9a9f;
      --grid: #1a1a1c;
      --accent: #cfcfcf;
      --border: #2a2a2d;
      --panel: #141416;
      --panel-alt: #19191c;
      --btn-hover: #1f1f23;
      --canvas-outline: #151517;
      --kbd-bg: #19191c;
      --overlay: rgba(0, 0, 0, 0.35);
      --game-over: #ddd;
    }
    :root[data-theme="light"] {
      color-scheme: light;
      --bg: #f4f6fb;
      --fg: #17181d;
      --mid: #5f6374;
      --grid: #d6dae6;
      --accent: #282c36;
      --border: #c4c8d5;
      --panel: #ffffff;
      --panel-alt: #eef2fa;
      --btn-hover: #e6ebf6;
      --canvas-outline: #ccd2e1;
      --kbd-bg: #e3e7f2;
      --overlay: rgba(255, 255, 255, 0.72);
      --game-over: #2a2e3a;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
      transition: background 0.25s ease, color 0.25s ease;
    }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; min-height: 100%; }
    header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    header .title { font-weight: 600; letter-spacing: .2px; }
    header .hud { display: flex; gap: 12px; align-items: center; font-variant-numeric: tabular-nums; flex-wrap: wrap; }
    header button {
      background: var(--panel-alt);
      color: var(--fg);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    header button:hover,
    header button:focus-visible {
      background: var(--btn-hover);
      border-color: var(--accent);
      outline: none;
    }

    .game { display: grid; place-items: center; padding: 10px; }
    canvas {
      display: block;
      background: var(--bg);
      border-radius: 10px;
      box-shadow: 0 0 0 1px var(--canvas-outline) inset;
      image-rendering: pixelated;
      transition: background 0.25s ease, box-shadow 0.25s ease;
    }

    footer {
      padding: 10px 14px 16px;
      color: var(--mid);
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      background: var(--panel);
      border-top: 1px solid var(--border);
    }
    kbd {
      background: var(--kbd-bg);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 4px;
      color: var(--accent);
    }

    /* Touch controls (visible on touch/coarse pointers) */
    .pad { position: fixed; bottom: 16px; right: 16px; display: none; gap: 8px; user-select: none; touch-action: none; }
    .pad .col { display: grid; gap: 8px; }
    .btn {
      width: 56px;
      height: 56px;
      display: grid;
      place-items: center;
      border-radius: 10px;
      background: var(--panel-alt);
      border: 1px solid var(--border);
      color: var(--fg);
      font-size: 20px;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .btn:active { background: var(--btn-hover); }
    @media (hover: none) and (pointer: coarse) {
      .pad { display: grid; grid-template-columns: auto auto auto; }
      .btn { width: clamp(52px, 14vw, 72px); height: clamp(52px, 14vw, 72px); font-size: clamp(18px, 5vw, 24px); }
      footer .keys { display: none; }
    }
  </style>
  <meta name="theme-color" content="#0f0f10" />
  <meta name="description" content="Jednoduchý had v jednom HTML souboru. Monochromatický a responzivní." />
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Had — monochromatický, responzivní</div>
      <div class="hud">
        <button id="btn-theme" type="button" aria-pressed="false" aria-label="Přepnout na světlý režim">Světlý režim</button>
        <div>Skóre: <span id="score">0</span></div>
        <button id="btn-pause" type="button" aria-pressed="false">Pozastavit</button>
        <button id="btn-restart" type="button">Restart</button>
      </div>
    </header>
    <main class="game">
      <canvas id="board" width="600" height="600" aria-label="Herní plocha — Had"></canvas>
    </main>
    <footer>
      <div class="keys">Ovládání: <kbd>šipky</kbd> / <kbd>WASD</kbd>. Pauza: <kbd>Space</kbd>. Restart po konci hry: <kbd>Enter</kbd> nebo tlačítko „Restart“.</div>
      <div>Tip: Na mobilu použijte ovládací šipky vpravo dole.</div>
    </footer>
  </div>

  <!-- Touch control pad -->
  <div class="pad" aria-hidden="true">
    <div class="col"></div>
    <div class="col">
      <div class="btn" data-dir="up">▲</div>
      <div class="btn" data-dir="down">▼</div>
    </div>
    <div class="col">
      <div class="btn" data-dir="left">◀</div>
      <div class="btn" data-dir="right">▶</div>
    </div>
  </div>

  <script>
  (function() {
    const canvas = document.getElementById('board');
    const headerEl = document.querySelector('header');
    const footerEl = document.querySelector('footer');
    const containerEl = document.querySelector('.game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const pauseBtn = document.getElementById('btn-pause');
    const restartBtn = document.getElementById('btn-restart');
    const themeBtn = document.getElementById('btn-theme');
    const themeMeta = document.querySelector('meta[name="theme-color"]');
    const prefersLight = window.matchMedia ? window.matchMedia('(prefers-color-scheme: light)') : null;
    const THEME_KEY = 'snake-theme';
    let currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';

    function applyTheme(theme, { persist = true } = {}) {
      currentTheme = theme === 'light' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', currentTheme);
      const rootStyles = getComputedStyle(document.documentElement);
      const bgColor = rootStyles.getPropertyValue('--bg').trim();
      if (bgColor && themeMeta) { themeMeta.setAttribute('content', bgColor); }
      if (themeBtn) {
        const nextTheme = currentTheme === 'light' ? 'tmavý' : 'světlý';
        themeBtn.textContent = currentTheme === 'light' ? 'Tmavý režim' : 'Světlý režim';
        themeBtn.setAttribute('aria-label', `Přepnout na ${nextTheme} režim`);
        themeBtn.setAttribute('aria-pressed', currentTheme === 'light' ? 'true' : 'false');
      }
      if (persist) {
        try { localStorage.setItem(THEME_KEY, currentTheme); } catch (err) { /* ignore */ }
      }
      if (state.food) { draw(); }
    }

    function initTheme() {
      let chosen = 'dark';
      try {
        const stored = localStorage.getItem(THEME_KEY);
        if (stored === 'light' || stored === 'dark') {
          chosen = stored;
        } else if (prefersLight?.matches) {
          chosen = 'light';
        }
      } catch (err) {
        if (prefersLight?.matches) { chosen = 'light'; }
      }
      applyTheme(chosen, { persist: false });
    }

    themeBtn?.addEventListener('click', () => {
      applyTheme(currentTheme === 'light' ? 'dark' : 'light');
    });

    prefersLight?.addEventListener('change', (event) => {
      try {
        if (!localStorage.getItem(THEME_KEY)) {
          applyTheme(event.matches ? 'light' : 'dark', { persist: false });
        }
      } catch (err) {
        applyTheme(event.matches ? 'light' : 'dark', { persist: false });
      }
    });

    // Game state
    let grid = 24; // cells per side (adaptive later)
    let cell = 24; // pixel size (computed)
    let speedMs = 110; // tick duration
    let lastTick = 0;
    let paused = false;
    let rafId = null;

    const state = {
      dir: { x: 1, y: 0 },
      nextDir: { x: 1, y: 0 },
      snake: [],
      food: null,
      score: 0,
      alive: true,
    };

    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function eq(a, b) { return a.x === b.x && a.y === b.y; }

    function init() {
      fitCanvas();
      const start = { x: Math.floor(grid/3), y: Math.floor(grid/2) };
      state.snake = [start, { x: start.x-1, y: start.y }, { x: start.x-2, y: start.y }];
      state.dir = { x: 1, y: 0 };
      state.nextDir = { x: 1, y: 0 };
      state.score = 0;
      state.alive = true;
      scoreEl.textContent = '0';
      placeFood();
      paused = false;
      pauseBtn.setAttribute('aria-pressed', 'false');
      loop(performance.now());
    }

    function fitCanvas() {
      // Compute available square area inside viewport minus header/footer and container padding
      const pad = getComputedStyle(containerEl);
      const padX = parseInt(pad.paddingLeft, 10) + parseInt(pad.paddingRight, 10);
      const padY = parseInt(pad.paddingTop, 10) + parseInt(pad.paddingBottom, 10);

      const availW = Math.max(0, Math.floor(window.innerWidth - padX));
      const availH = Math.max(0, Math.floor(window.innerHeight - (headerEl?.offsetHeight || 0) - (footerEl?.offsetHeight || 0) - padY));
      const size = Math.max(280, Math.min(900, Math.floor(Math.min(availW, availH))));

      // Set both drawing buffer and CSS size explicitly to avoid overflow/scroll
      canvas.width = canvas.height = size;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';

      // Choose grid so that cells are about 18–26 px
      const targetCell = Math.max(18, Math.min(26, Math.floor(size / 24)));
      grid = Math.max(16, Math.min(40, Math.round(size / targetCell)));
      cell = Math.floor(size / grid);
      // Adjust speed a bit with grid size
      speedMs = Math.max(70, Math.min(140, Math.round(2500 / grid)));
    }

    function placeFood() {
      while (true) {
        const f = { x: randInt(0, grid-1), y: randInt(0, grid-1) };
        if (!state.snake.some(s => eq(s, f))) { state.food = f; return; }
      }
    }

    function step() {
      if (!state.alive || paused) return;
      // apply nextDir if it isn't reversing
      if ((state.dir.x + state.nextDir.x !== 0) || (state.dir.y + state.nextDir.y !== 0)) {
        state.dir = { ...state.nextDir };
      }

      const head = state.snake[0];
      const next = { x: head.x + state.dir.x, y: head.y + state.dir.y };

      // collisions: walls
      if (next.x < 0 || next.y < 0 || next.x >= grid || next.y >= grid) {
        state.alive = false; return;
      }
      // collisions: self
      if (state.snake.some((s, i) => i !== 0 && eq(s, next))) {
        state.alive = false; return;
      }

      state.snake.unshift(next);
      if (eq(next, state.food)) {
        state.score += 1;
        scoreEl.textContent = String(state.score);
        placeFood();
      } else {
        state.snake.pop();
      }
    }

    function draw() {
      // background and grid
      const styles = getComputedStyle(document.documentElement);
      ctx.fillStyle = styles.getPropertyValue('--bg');
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const g = styles.getPropertyValue('--grid');
      ctx.strokeStyle = g; ctx.lineWidth = 1;
      for (let i = 1; i < grid; i++) {
        const p = Math.floor(i * cell) + 0.5;
        ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, canvas.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(canvas.width, p); ctx.stroke();
      }

      // food
      ctx.fillStyle = styles.getPropertyValue('--mid');
      roundRect(ctx, state.food.x * cell + 2, state.food.y * cell + 2, cell - 4, cell - 4, 5);
      ctx.fill();

      // snake
      ctx.fillStyle = styles.getPropertyValue('--fg');
      state.snake.forEach((s, idx) => {
        const r = idx === 0 ? 8 : 6;
        roundRect(ctx, s.x * cell + 1, s.y * cell + 1, cell - 2, cell - 2, r);
        ctx.fill();
      });

      // game over overlay
      if (!state.alive) {
        const overlay = styles.getPropertyValue('--overlay').trim() || 'rgba(0,0,0,0.35)';
        const gameOverColor = styles.getPropertyValue('--game-over').trim() || '#ddd';
        ctx.fillStyle = overlay;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = gameOverColor;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = Math.floor(canvas.width * 0.06) + 'px system-ui, sans-serif';
        ctx.fillText('Konec hry', canvas.width/2, canvas.height/2 - 24);
        ctx.font = Math.floor(canvas.width * 0.03) + 'px system-ui, sans-serif';
        ctx.fillText('Stiskni Restart pro novou hru', canvas.width/2, canvas.height/2 + 20);
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function loop(ts) {
      if (paused) { draw(); rafId = requestAnimationFrame(loop); return; }
      if (!lastTick) lastTick = ts;
      const dt = ts - lastTick;
      if (dt >= speedMs) { lastTick = ts; step(); }
      draw();
      rafId = requestAnimationFrame(loop);
    }

    // Controls
    function setDir(dx, dy) {
      // prevent immediate reverse
      if ((dx !== 0 && state.dir.x !== 0) || (dy !== 0 && state.dir.y !== 0)) return;
      state.nextDir = { x: dx, y: dy };
    }
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (!state.alive) { e.preventDefault(); cancelAnimationFrame(rafId); lastTick = 0; init(); }
        return;
      }
      if (e.key === ' ' || e.code === 'Space') { togglePause(); return; }
      switch (e.key) {
        case 'ArrowLeft': case 'a': case 'A': setDir(-1, 0); break;
        case 'ArrowRight': case 'd': case 'D': setDir(1, 0); break;
        case 'ArrowUp': case 'w': case 'W': setDir(0, -1); break;
        case 'ArrowDown': case 's': case 'S': setDir(0, 1); break;
      }
    });

    // Touch buttons
    document.querySelectorAll('.btn[data-dir]').forEach(btn => {
      const dir = btn.getAttribute('data-dir');
      const handler = (ev) => {
        ev.preventDefault();
        if (dir === 'up') setDir(0, -1);
        if (dir === 'down') setDir(0, 1);
        if (dir === 'left') setDir(-1, 0);
        if (dir === 'right') setDir(1, 0);
      };
      btn.addEventListener('pointerdown', handler, { passive: false });
    });

    // Buttons
    function togglePause() {
      paused = !paused;
      pauseBtn.setAttribute('aria-pressed', paused ? 'true' : 'false');
    }
    pauseBtn.addEventListener('click', togglePause);
    restartBtn.addEventListener('click', () => { cancelAnimationFrame(rafId); lastTick = 0; init(); });

    // Resize handling
    let resizeTimer = 0;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => { const alive = state.alive; fitCanvas(); if (!alive) draw(); }, 120);
    });

    // Start
    initTheme();
    init();
  })();
  </script>
</body>
</html>
